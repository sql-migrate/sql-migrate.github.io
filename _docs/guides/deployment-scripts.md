---
title: Deployment Scripts
description: Generate and customize SQL deployment scripts
category: guides
order: 5
permalink: /docs/guides/deployment-scripts/
---

PostgresCompare generates SQL scripts that update your target database to match the source. This guide covers how to generate, customize, and safely deploy these scripts.

## Generating Scripts

After running a comparison:

1. Review the differences in the results view
2. Select which changes to include (checked by default)
3. Click **Generate Script** in the toolbar
4. Choose a save location for the `.sql` file

The generated script includes all selected changes in dependency order.

## Script Structure

A typical deployment script includes:

```sql
-- PostgresCompare Deployment Script
-- Generated: 2024-01-15 10:30:00
-- Source: production-db
-- Target: staging-db

BEGIN;

-- Create new types
CREATE TYPE public.status_type AS ENUM ('active', 'inactive', 'pending');

-- Create new tables
CREATE TABLE public.audit_log (
    id SERIAL PRIMARY KEY,
    action VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Alter existing tables
ALTER TABLE public.users ADD COLUMN last_login TIMESTAMP;

-- Create new functions
CREATE OR REPLACE FUNCTION public.get_active_users()
RETURNS SETOF public.users AS $$
    SELECT * FROM public.users WHERE status = 'active';
$$ LANGUAGE SQL;

-- Create indexes
CREATE INDEX idx_users_status ON public.users(status);

COMMIT;
```

## Script Options

Customize how scripts are generated:

### Transaction Wrapping

- **Wrap in transaction** - Enclose all statements in BEGIN/COMMIT
- **Use savepoints** - Add SAVEPOINTs for partial rollback
- **No transaction** - Individual statements (for large changes)

### Statement Options

- **Include IF EXISTS** - Safer DROP statements
- **Include IF NOT EXISTS** - Safer CREATE statements
- **Add comments** - Include object descriptions as comments
- **Separate files** - One file per object type

### Ordering Options

- **Dependency order** - PostgresCompare default, respects references
- **Alphabetical within type** - Easier to review
- **Custom order** - Drag and drop in UI

## Customizing Generated SQL

Before saving, you can customize the script:

### In the Preview Window

1. Click **Preview Script** before generating
2. Edit SQL directly in the preview
3. Click **Save** to write the file

### Post-Generation

1. Open the generated `.sql` file
2. Add custom statements (data migrations, etc.)
3. Adjust statement order if needed
4. Add your own transaction handling

## Handling Data Migrations

Schema changes often require data migrations. PostgresCompare generates DDL only, but you can add data migration statements:

### Column Type Changes

```sql
-- Generated by PostgresCompare
ALTER TABLE public.orders ALTER COLUMN amount TYPE NUMERIC(12,2);

-- Add manual data conversion
UPDATE public.orders SET amount = ROUND(amount, 2) WHERE amount IS NOT NULL;
```

### Adding NOT NULL Constraints

```sql
-- First, handle existing NULL values
UPDATE public.users SET email = 'unknown@example.com' WHERE email IS NULL;

-- Then add the constraint (generated by PostgresCompare)
ALTER TABLE public.users ALTER COLUMN email SET NOT NULL;
```

### Renaming Columns

PostgresCompare may detect renames as drop + create. For data preservation:

```sql
-- Instead of DROP + ADD, use RENAME
ALTER TABLE public.users RENAME COLUMN username TO user_name;
```

## Script Templates

Create reusable templates for common patterns:

### Pre-Deployment Checks

```sql
-- Check PostgreSQL version
DO $$
BEGIN
    IF current_setting('server_version_num')::int < 120000 THEN
        RAISE EXCEPTION 'PostgreSQL 12 or higher required';
    END IF;
END $$;

-- Check for active connections
DO $$
DECLARE
    active_count INT;
BEGIN
    SELECT COUNT(*) INTO active_count
    FROM pg_stat_activity
    WHERE datname = current_database() AND state = 'active' AND pid != pg_backend_pid();

    IF active_count > 5 THEN
        RAISE WARNING 'Multiple active connections detected: %', active_count;
    END IF;
END $$;
```

### Post-Deployment Verification

```sql
-- Verify new objects exist
DO $$
BEGIN
    ASSERT EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_name = 'audit_log'
    ), 'audit_log table was not created';
END $$;

-- Verify constraints
DO $$
BEGIN
    ASSERT EXISTS (
        SELECT 1 FROM information_schema.table_constraints
        WHERE constraint_name = 'users_email_unique'
    ), 'users_email_unique constraint was not created';
END $$;
```

## Splitting Large Scripts

For large deployments, consider splitting scripts:

### By Object Type

1. In **Generate Script** options, select **Separate files**
2. Creates: `tables.sql`, `views.sql`, `functions.sql`, etc.
3. Deploy in dependency order

### By Risk Level

1. Low risk: New objects, comments
2. Medium risk: Modifications to existing objects
3. High risk: Drops, data type changes

### By Application Module

1. Split changes by feature or module
2. Deploy and verify incrementally
3. Easier rollback if issues arise

## Version Control

Store deployment scripts in version control:

```
migrations/
├── 2024-01-15-add-audit-table.sql
├── 2024-01-20-update-user-columns.sql
└── 2024-02-01-add-indexes.sql
```

Include metadata in script comments:

```sql
-- Migration: Add audit table
-- Ticket: PROJ-1234
-- Author: john.doe
-- Generated: PostgresCompare 4.0.1
-- Tested: staging-db 2024-01-14
```

## Next Steps

- [Safe deployments](/docs/guides/safe-deployments/) - Best practices for running deployment scripts
- [CI/CD integration](/docs/guides/ci-cd-integration/) - Automate script generation
- [Troubleshooting](/docs/troubleshooting/common-issues/) - Common issues and solutions
