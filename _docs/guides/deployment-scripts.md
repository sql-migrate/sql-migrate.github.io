---
title: Deployment Scripts
description: Generate and customize SQL deployment scripts
category: guides
order: 5
permalink: /docs/guides/deployment-scripts/
---

PostgresCompare generates SQL scripts that synchronize your databases. This guide covers how to generate, customize, and safely deploy these scripts.

## Generating Scripts

After running a comparison:

1. Review the differences in the results view
2. Select which changes to include using the checkboxes
3. Click **Generate Script** in the toolbar

The generated script includes all selected changes in dependency order.

## Script Structure

Generated scripts include a header with metadata followed by statements grouped into labeled sections:

```sql
-- PostgresCompare Deployment Script
-- Version: 1.1.103
-- X: production-db
-- Y: staging-db
-- Generated: 2026-02-18 10:30:00

BEGIN;

/*** Tables ***/

CREATE TABLE public.audit_log (
    id SERIAL PRIMARY KEY,
    action VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

/*** Types ***/

CREATE TYPE public.status_type AS ENUM ('active', 'inactive', 'pending');

/*** Column Changes ***/

ALTER TABLE public.users ADD COLUMN last_login TIMESTAMP;

/*** Functions ***/

-- depends on: public.users
CREATE OR REPLACE FUNCTION public.get_active_users()
RETURNS SETOF public.users AS $$
    SELECT * FROM public.users WHERE status = 'active';
$$ LANGUAGE SQL;

/*** Indexes ***/

CREATE INDEX idx_users_status ON public.users(status);

COMMIT;
```

Sections appear only when the script contains objects of that type. Dependency comments (`-- depends on`, `-- required by`) explain the ordering of dependency-sorted objects.

## Destructive Change Warnings

Before you run a script, PostgresCompare classifies every statement by risk level and surfaces warnings in the UI:

| Level | Examples | Indicators |
|-------|----------|------------|
| **Destructive** | `DROP TABLE`, `DROP COLUMN` | Red row, warning icon, glyph marker in editor |
| **Warning** | `DROP FUNCTION`, `DROP VIEW` | Amber row, warning icon, glyph marker in editor |

A summary banner above the statement list shows the total count of destructive and warning statements. Review these carefully before proceeding — destructive statements can cause data loss that cannot be automatically reversed.

## Previewing Differences

Hover over any row in the statement list to see a floating diff popover showing the before and after SQL side-by-side. This lets you inspect individual changes without leaving the script screen.

## Navigating the Statement List

Statements are grouped under clickable section headers (Tables, Views, Types, Sequences, Column Changes, Constraints, Indexes, Functions, Materialized Views, Triggers, Policies, Privileges, Drop Objects). Click a section header in the list to jump directly to that section in the SQL editor.

## Transaction Wrapping

Scripts can be wrapped in a transaction block (BEGIN/COMMIT) so that all changes are applied atomically. If any statement fails, the entire transaction is rolled back.

## Direct Deployment

In addition to generating SQL scripts, PostgresCompare can deploy changes directly to the target database:

1. Review and select the changes to deploy
2. Click the **Deploy** button
3. Monitor deployment progress in the progress tracker
4. Review the deployment results

Direct deployment provides real-time progress tracking and immediate feedback on success or failure.

## Deployment History

PostgresCompare tracks deployment history within the project. You can review past deployments to see what was changed and when, providing an audit trail for your database changes.

## Post-Deployment Comparison

After deploying changes, run a new comparison to verify the deployment was successful. This confirms that the target database now matches the expected state and helps catch any issues immediately.

## Handling Data Migrations

Schema changes often require data migrations. PostgresCompare generates DDL only, but you can add data migration statements to the generated script:

### Column Type Changes

```sql
-- Generated by PostgresCompare
ALTER TABLE public.orders ALTER COLUMN amount TYPE NUMERIC(12,2);

-- Add manual data conversion
UPDATE public.orders SET amount = ROUND(amount, 2) WHERE amount IS NOT NULL;
```

### Adding NOT NULL Constraints

```sql
-- First, handle existing NULL values
UPDATE public.users SET email = 'unknown@example.com' WHERE email IS NULL;

-- Then add the constraint (generated by PostgresCompare)
ALTER TABLE public.users ALTER COLUMN email SET NOT NULL;
```

### Renaming Columns

PostgresCompare may detect renames as drop + create. For data preservation:

```sql
-- Instead of DROP + ADD, use RENAME
ALTER TABLE public.users RENAME COLUMN username TO user_name;
```

## Script Templates

Create reusable templates for common patterns:

### Pre-Deployment Checks

```sql
-- Check PostgreSQL version
DO $$
BEGIN
    IF current_setting('server_version_num')::int < 120000 THEN
        RAISE EXCEPTION 'PostgreSQL 12 or higher required';
    END IF;
END $$;

-- Check for active connections
DO $$
DECLARE
    active_count INT;
BEGIN
    SELECT COUNT(*) INTO active_count
    FROM pg_stat_activity
    WHERE datname = current_database() AND state = 'active' AND pid != pg_backend_pid();

    IF active_count > 5 THEN
        RAISE WARNING 'Multiple active connections detected: %', active_count;
    END IF;
END $$;
```

### Post-Deployment Verification

```sql
-- Verify new objects exist
DO $$
BEGIN
    ASSERT EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_name = 'audit_log'
    ), 'audit_log table was not created';
END $$;

-- Verify constraints
DO $$
BEGIN
    ASSERT EXISTS (
        SELECT 1 FROM information_schema.table_constraints
        WHERE constraint_name = 'users_email_unique'
    ), 'users_email_unique constraint was not created';
END $$;
```

## Splitting Large Deployments

For large deployments, consider splitting changes:

### By Risk Level

1. Low risk: New objects, comments
2. Medium risk: Modifications to existing objects
3. High risk: Drops, data type changes

### By Application Module

1. Split changes by feature or module
2. Deploy and verify incrementally
3. Easier rollback if issues arise

## Version Control

Store deployment scripts in version control:

```
migrations/
├── 2024-01-15-add-audit-table.sql
├── 2024-01-20-update-user-columns.sql
└── 2024-02-01-add-indexes.sql
```

Include metadata in script comments:

```sql
-- Migration: Add audit table
-- Ticket: PROJ-1234
-- Author: john.doe
-- Generated: PostgresCompare 4.0.1
-- Tested: staging-db 2024-01-14
```

## Next Steps

- [Safe deployments](/docs/guides/safe-deployments/) - Best practices for running deployment scripts
- [Comparing databases](/docs/guides/comparing-databases/) - Advanced comparison techniques
- [Troubleshooting](/docs/troubleshooting/common-issues/) - Common issues and solutions
